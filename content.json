{"meta":{"title":"Hello xukang","subtitle":"","description":"","author":"xukang","url":"https://xukang919.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"/404.html","permalink":"https://xukang919.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-19T04:23:41.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"about/index.html","permalink":"https://xukang919.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-10-19T03:34:26.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"books/index.html","permalink":"https://xukang919.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://xukang919.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-19T02:29:56.000Z","updated":"2020-10-19T01:27:00.000Z","comments":true,"path":"links/index.html","permalink":"https://xukang919.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-19T02:26:54.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"repository/index.html","permalink":"https://xukang919.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"tags/index.html","permalink":"https://xukang919.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode 94 二叉树的中序遍历","slug":"Leetcode 94 二叉树的中序遍历","date":"2021-05-18T14:01:23.000Z","updated":"2021-05-18T14:01:32.000Z","comments":true,"path":"2021/05/18/Leetcode 94 二叉树的中序遍历/","link":"","permalink":"https://xukang919.github.io/2021/05/18/Leetcode%2094%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","excerpt":"","text":"方法1、暴力递归 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; inorder(root, res); return res; &#125; void inorder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123; if (root != nullptr) &#123; inorder(root-&gt;left, res); res.push_back(root-&gt;val); inorder(root-&gt;right, res); &#125; &#125;&#125;; 方法 2、颜色标记法 这里每个结点都遍历两次！ 使用栈来深度遍历二叉树，只有非空节点才压入栈中 非空节点才压入栈中 非空节点才压入栈中 这里需要用到三种数据结构 vector #include &lt;vector&gt; 添加元素 push_back() stack #include &lt;stack&gt; 添加元素（压栈） push() 栈顶元素 top() 删除元素（出栈） pop() pair 对于pair一定要消除一个误区，pair跟map没有绝对关系，并不是在map下才有pair。由于是学map时学的pair给人一种错觉。 #include &lt;utility&gt; 创建pair的两种方法 123456//方法1 跟所有类创建对象一样，也就是使用构造函数pair&lt;TreeNode *, int&gt; my_pair(root, 1);pair&lt;TreeNode *, int&gt;(root, 1)； //匿名pair对象//方法2 使用make_pair函数模板，其实就是利用拷贝构造函数！pair&lt;TreeNode *, int&gt; my_pair = make_pair(root, 1);make_pair(root, 1)； //匿名pair对象 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; std::vector&lt;int&gt; res; if(root == NULL) return res; std::stack&lt;pair&lt;TreeNode *, int&gt;&gt; stk; stk.push(pair&lt;TreeNode *, int&gt;(root, 1)); while(!stk.empty())&#123; pair&lt;TreeNode *, int&gt; tmp = stk.top(); stk.pop(); if(tmp.second == 0) res.push_back(tmp.first-&gt;val); else&#123; if(tmp.first-&gt;right != NULL) // 非空节点才压入栈中 stk.push(pair&lt;TreeNode *, int&gt;(tmp.first-&gt;right, 1)); stk.push(pair&lt;TreeNode *,int&gt;(tmp.first, 0)); if(tmp.first-&gt;left != NULL) //非空节点才压入栈中 stk.push(pair&lt;TreeNode *, int&gt;(tmp.first-&gt;left, 1)); &#125; &#125; return res; &#125;&#125;; 方法3、左链入栈 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode *&gt; stk; auto p = root; while (p) &#123; stk.push(p); p = p-&gt;left; &#125; while (!stk.empty()) &#123; auto tmp = stk.top(); stk.pop(); res.push_back(tmp-&gt;val); p = tmp-&gt;right; while (p) &#123; stk.push(p); p = p-&gt;left; &#125; &#125; return res; &#125;&#125;; 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if (root == nullptr) return res; stack&lt;TreeNode *&gt; stk; auto p = root; while (p != nullptr || !stk.empty()) &#123; while (p != nullptr) &#123; stk.push(p); p = p-&gt;left; &#125; auto tmp = stk.top(); stk.pop(); res.push_back(tmp-&gt;val); p = tmp-&gt;right; &#125; return res; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://xukang919.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://xukang919.github.io/tags/bfs/"}]},{"title":"Leetcode 11 盛水最多的容器","slug":"Leetcode 11 盛水最多的容器","date":"2020-10-26T07:32:05.000Z","updated":"2020-10-21T08:10:16.000Z","comments":true,"path":"2020/10/26/Leetcode 11 盛水最多的容器/","link":"","permalink":"https://xukang919.github.io/2020/10/26/Leetcode%2011%20%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/","excerpt":"","text":"方法1、双循环枚举 时间复杂度 O(N^2) 12345678910111213class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int res = 0; for (int i = 0; i &lt; height.size() - 1; i++) &#123; for (int j = i + 1; j &lt; height.size(); j++) &#123; res = max(res, min(height[i], height[j]) * (j - i)); &#125; &#125; return res; &#125;&#125;; 方法2、双指针 对于双指针方法，数组和链表相关题目经常会用到 时间复杂度 O(N) 为什么双指针的做法是正确的？ 双指针代表了什么？ ​ 双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。 为什么对应的数字较小的那个指针不可能再作为容器的边界了? ​ 反正法 ： 假设当前左指针和右指针指向的数分别为 x 和 y，不失一般性，我们假设 x &lt;= y。同时，两个指针之间的距离为 t 。那么，它们组成的容器的容量为： ​ min(x, y) ∗ t = x ∗ t 我们可以断定，如果我们保持左指针的位置不变，右指针往左移，这个容器的容量就不会超过 x ∗ t了。 如果我们任意向左移动右指针，指向的数为 y1 ，两个指针之间的距离为 t1 ，那么显然有 t1 &lt; t，并且 min (x, y1) &lt;= min (x , y)： 如果 y1 &lt;= y，那么 min(x, y1) &lt;= min(x, y)； 如果 y1 &gt; y ， 那么 min(x, y1) = x = min(x, y); 结合 t1 &lt; t 和 min (x, y1) &lt;= min (x , y) 得到 min(x, y1) ∗ t1 &lt; min(x, y) ∗ t 即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，我们可以通过移动指向较小值的那个指针，来遍历数组，达到减少时间复杂度的效果 12345678910111213141516171819202122232425class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int res = 0; int i = 0; int j = height.size() - 1; while (i &lt; j) &#123; // if (height[i] &lt;= height[j]) &#123; // res = max(res, height[i] * (j - i)); // i++; // &#125; else &#123; // res = max(res, height[j] * (j - i)); // j--; // &#125; /* 三目表达式虽然优雅！但是容易犯错！ 如果(j - i) * height[i++] 写成 height[i++] * (j - i) 就出错了！ */ res = height[i] &lt;= height[j] ? max(res, (j - i) * height[i++]) : max(res, (j - i) * height[j--]); &#125; return res; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"},{"name":"双指针","slug":"双指针","permalink":"https://xukang919.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"c++ STL_算术算法","slug":"c++ STL_算术算法","date":"2020-10-25T01:34:23.000Z","updated":"2020-10-20T02:00:43.000Z","comments":true,"path":"2020/10/25/c++ STL_算术算法/","link":"","permalink":"https://xukang919.github.io/2020/10/25/c++%20STL_%E7%AE%97%E6%9C%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;numeric&gt;void my_print(int &amp;a)&#123; std::cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;int main() &#123; std::vector&lt;int&gt; v; for (int i = 0; i &lt;= 10; i++) &#123; v.push_back(i); &#125; std::for_each(v.begin(), v.end(), my_print); std::cout &lt;&lt; std::endl; int res = std::accumulate(v.begin(), v.end(), 0); std::cout &lt;&lt; res &lt;&lt; std::endl; res = std::accumulate(v.begin(), v.end(), 5); std::cout &lt;&lt; res &lt;&lt; std::endl; std::fill(v.begin()+5, v.end(), 10); std::for_each(v.begin(), v.end(), my_print); std::cout &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xukang919.github.io/tags/STL/"},{"name":"算法","slug":"算法","permalink":"https://xukang919.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 84 柱状图中最大的矩形","slug":"Leetcode 84 柱状图中最大的矩形","date":"2020-10-24T13:36:42.000Z","updated":"2020-10-24T02:41:45.000Z","comments":true,"path":"2020/10/24/Leetcode 84 柱状图中最大的矩形/","link":"","permalink":"https://xukang919.github.io/2020/10/24/Leetcode%2084%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/","excerpt":"","text":"做题感受： 弄清楚暴力算法往往是得到优化算法的第一步 对于这道题，不仅仅满足于掌握单调栈的优化算法， 更重要的是，先把暴力算法弄懂，弄透，想想暴力算法的不足之处。 想想这些不足该怎么优化办法，感受学习人家的优化方法。 这样才能够真正弄懂优化算法优化了什么，才能感受到优化算法的妙处， 与这道题相似的接雨水，其优化算法相对比较有跳跃性！不像这道题循序渐进，容易理解优化算法。 我们需要在柱状图中找出最大的矩形，因此我们可以考虑枚举矩形的宽和高，其中「宽」表示矩形贴着柱状图底边的宽度，「高」表示矩形在柱状图上的高度。这道题枚举「高」很容易想出！ 方法1、暴力枚举 ”高“ 从左往右遍历「高」，然后找每个高度的 左边第一个小于它的位置，右边第一个小于它的位置，从而得到对应的「底」 123456789101112131415161718class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; for (int i = 0; i &lt; heights.size(); i++) &#123; int height = heights[i]; int j = i - 1; int k = i + 1; while (j &gt;= 0 &amp;&amp; heights[j] &gt;= heights[i]) j--; while (k &lt; heights.size() &amp;&amp; heights[k] &gt;= heights[i]) k++; res = max(res, height * (k - j - 1)); &#125; return res; &#125;&#125;; 方法2、枚举 ”高“的优化，使用栈 把暴力方法弄清楚之后，很容易发现这几个问题！ 我们从左往右遍历「高」，然后找每个高度的 左边第一个小于它的位置，右边第一个小于它的位置。发现有重复搜索，可以利用一个单调栈，来存储已经查找过的数据。 对于某个「高」 heights[i] , 如果没有找到小于它的。也就是说，左右两边都大于它。 最后搜索的下标会来到 -1 和 size ( = heights.size( ) )。 因此其左边界 为-1，右边界 size。同样，第一个元素的左边界为-1，最后一个元素的右边界为size。 利用单调栈存储「高」。 当前heights[i] &gt;= heights[stk.top()],就将其下标压入栈中！ 当前heights[i] &lt; heights[stk.top()], 说明 「高」 heights[stk.top()]的右边第一个小于它的位置就是 i 。又由于是单调递增栈，其栈中的前面一个下标，可以当做其左边第一个小于它的位置。但是如果有重复元素的话，严格来说不应该是，但是会发现这个结果是肯定会被下面的值覆盖。对于栈首元素，其左边界就是-1。当遍历完整个数组，单调递增栈肯定还有高度没有求！这些元素的右边界都是size。 1234567891011121314151617181920212223class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; stack&lt;int&gt; stk; int size = heights.size(); for (int i = 0; i &lt; size; i++) &#123; while (!stk.empty() &amp;&amp; heights[i] &lt; heights[stk.top()]) &#123; int tmp = stk.top(); stk.pop(); res = max(res, heights[tmp] * (stk.empty() ? i : i - stk.top() - 1)); &#125; stk.push(i); &#125; while (!stk.empty()) &#123; int tmp = stk.top(); stk.pop(); res = max(res, heights[tmp] * (stk.empty() ? size : size - stk.top() - 1)); &#125; return res; &#125;&#125;; 对于栈首元素，其左边界就是-1，我们可以将其先压入栈中，这样就可以统一了。 12345678910111213141516171819202122232425class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; std::stack&lt;int&gt; stk; stk.push(-1); //左边界-1，可以提前加进去，i= i -（-1）+ 1； for (int i = 0; i &lt; heights.size(); i++) &#123; while (stk.size() &gt; 1 &amp;&amp; heights[i] &lt; heights[stk.top()]) &#123; int tmp = stk.top(); stk.pop(); //由于stk添加了一个-1，这里的弹出操作，永远不会将stk变为空 res = max(res , heights[tmp] * (i - stk.top() - 1)); &#125; stk.push(i); &#125; while (stk.size() &gt; 1) &#123; int tmp = stk.top(); stk.pop(); //(int)heights.size() 无符号整数计算要小心！ res = max(res , heights[tmp] * ((int)heights.size() - stk.top() - 1)); &#125; return res; &#125;&#125;; 方法3、枚举 ”高“的再优化，使用 栈 + 哨兵 我们可以添加一个哨兵，将代码更加优化！ 123456789101112131415161718class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; std::stack&lt;int&gt; stk; heights.push_back(0); //添加一个哨兵！可以将最后的循环合并！ for (int i = 0; i &lt; heights.size(); i++) &#123; while (!stk.empty() &amp;&amp; heights[i] &lt; heights[stk.top()]) &#123; int tmp = stk.top(); stk.pop(); res = max(res , heights[tmp] * (stk.empty() ? i : (i - stk.top() - 1))); &#125; stk.push(i); &#125; return res; &#125;&#125;; 123456789101112131415161718class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; std::stack&lt;int&gt; stk; stk.push(-1); heights.push_back(0); //添加一个哨兵！可以将最后的循环合并！ for (int i = 0; i &lt; heights.size(); i++) &#123; while (stk.size() &gt; 1 &amp;&amp; heights[i] &lt; heights[stk.top()]) &#123; int tmp = stk.top(); stk.pop(); res = max(res , heights[tmp] * (i - stk.top() - 1)); &#125; stk.push(i); &#125; return res; &#125;&#125;; 其实除了将左边界 -1加进stack + 一个哨兵，还可以直接使用两个哨兵 1234567891011121314151617181920class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; stack&lt;int&gt; stk; heights.push_back(0); heights.insert(heights.begin(), 0); for (int i = 0; i &lt; heights.size(); i++) &#123; while (!stk.empty() &amp;&amp; heights[i] &lt; heights[stk.top()]) &#123; int tmp = stk.top(); stk.pop(); res = max(res, heights[tmp] * (i - stk.top() - 1)); &#125; stk.push(i); &#125; return res; &#125;&#125;; 总结下来，右边界的优化用哨兵！左边界可以用哨兵，也可以直接往栈中添加左边界！","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xukang919.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"c++ STL_拷贝替换算法","slug":"c++ STL_拷贝替换算法","date":"2020-10-24T02:45:12.000Z","updated":"2020-10-20T01:58:54.000Z","comments":true,"path":"2020/10/24/c++ STL_拷贝替换算法/","link":"","permalink":"https://xukang919.github.io/2020/10/24/c++%20STL_%E6%8B%B7%E8%B4%9D%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;sys/time.h&gt;class Person&#123;public: Person() &#123;&#125; Person(const std::string &amp;name, int age) : name(name), age(age) &#123;&#125; bool operator&gt;(const Person &amp;p) const&#123; return this-&gt;age &gt; p.age; &#125; bool operator&lt;(const Person &amp;p) const&#123; return this-&gt;age &lt; p.age; &#125; bool operator==(const Person &amp;p) const&#123; if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) return true; else return false; &#125; std::string name; int age;&#125;;Person &amp; my_func(Person &amp;p)&#123; p.age ++; return p;&#125;void my_print(Person &amp;p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt;p.age &lt;&lt; &quot; &quot;;&#125;class my_Print&#123;public: void operator()(Person &amp;p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt;p.age &lt;&lt;&quot; &quot;; &#125;&#125;;class my_compare&#123;public: bool operator()(const Person&amp; p)&#123; if(p.name == &quot;橘右京&quot;) return true; return false; &#125;&#125;;int main() &#123; Person p1(&quot;张飞&quot; , 100); Person p2(&quot;赵云&quot; , 90); Person p3(&quot;关羽&quot; , 110); Person p4(&quot;马超&quot; , 80); Person p5(&quot;黄忠&quot; , 120);// std::cout &lt;&lt; (p1&gt;p2) &lt;&lt; std::endl; std::vector&lt;Person&gt; vct; vct.push_back(p1); vct.push_back(p2); vct.push_back(p3); vct.push_back(p4); vct.push_back(p5); std::for_each(vct.begin(), vct.end(), my_Print()); std::cout &lt;&lt; std::endl; std::vector&lt;Person&gt; new_vct; new_vct.resize(vct.size()-2); std::copy(vct.begin(), vct.end()-2, new_vct.begin()); std::for_each(new_vct.begin(), new_vct.end(), my_print); std::cout &lt;&lt; std::endl; std::replace(new_vct.begin(), new_vct.end(), Person(&quot;关羽&quot;,110), Person(&quot;橘右京&quot;, 120)); std::for_each(new_vct.begin(), new_vct.end(), my_Print()); std::cout &lt;&lt; std::endl; std::replace_if(new_vct.begin(), new_vct.end(), my_compare(), Person(&quot;关羽&quot;, 110)); std::for_each(new_vct.begin(), new_vct.end(), my_Print()); std::cout &lt;&lt; std::endl; std::cout &lt;&lt; &quot;------------------&quot;&lt;&lt;std::endl; std::swap(new_vct, vct); std::for_each(new_vct.begin(), new_vct.end(), my_Print()); std::cout &lt;&lt; std::endl; std::for_each(vct.begin(), vct.end(), my_Print()); std::cout &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xukang919.github.io/tags/STL/"},{"name":"算法","slug":"算法","permalink":"https://xukang919.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 42 接雨水","slug":"Leetcode 42 接雨水","date":"2020-10-23T14:25:55.000Z","updated":"2020-10-23T14:26:26.000Z","comments":true,"path":"2020/10/23/Leetcode 42 接雨水/","link":"","permalink":"https://xukang919.github.io/2020/10/23/Leetcode%2042%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/","excerpt":"","text":"方法1、暴力 对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。 12345678910111213141516int trap(vector&lt;int&gt;&amp; height)&#123; int ans = 0; int size = height.size(); for (int i = 1; i &lt; size - 1; i++) &#123; int max_left = 0, max_right = 0; for (int j = i; j &gt;= 0; j--) &#123; //Search the left part for max bar size max_left = max(max_left, height[j]); &#125; for (int j = i; j &lt; size; j++) &#123; //Search the right part for max bar size max_right = max(max_right, height[j]); &#125; ans += min(max_left, max_right) - height[i]; &#125; return ans;&#125; 方法2、单调栈 这里的单调栈跳跃比较大，不像「柱状图的最大矩形」那道题直接是暴力法的优化。这道题的单调栈，更像是一种高级算法，而不是优化算法。 而且这里的头尾元素不需要考虑，没法积水！ 当height[i] &lt;= height[stk.top()],压入栈。否则，在栈顶元素出形成一个低洼！同样注意一下重复元素是怎么处理的！ 1234567891011121314151617int trap(vector&lt;int&gt;&amp; height) &#123; stack&lt;int&gt; stk; int i = 0; int res = 0; while (i &lt; height.size()) &#123; while (!stk.empty() &amp;&amp; height[i] &gt; height[stk.top()]) &#123; int tmp = stk.top(); stk.pop(); if (stk.empty()) break; res += (min(height[i], height[stk.top()]) - height[tmp]) * (i - stk.top() - 1); &#125; stk.push(i++); &#125; return res; &#125; 方法3、双指针 一行一行的算 1234567891011121314151617181920212223class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int max_height = 0; for (int i = 0; i &lt; height.size(); i++) &#123; max_height = max(max_height, height[i]); &#125; int left = 0, right = height.size() - 1; int res = 0; for (int i = 1; i &lt;= max_height; i++) &#123; while (height[left] &lt; i) left++; while (height[right] &lt; i) right--; res += right - left + 1; &#125; for (int i = 0; i &lt; height.size(); i++) &#123; res -= height[i]; &#125; return res; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xukang919.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]},{"title":"Leetcode 200 岛屿数量","slug":"Leetcode 200 岛屿数量","date":"2020-10-22T13:52:23.000Z","updated":"2020-10-22T14:03:46.000Z","comments":true,"path":"2020/10/22/Leetcode 200 岛屿数量/","link":"","permalink":"https://xukang919.github.io/2020/10/22/Leetcode%20200%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","excerpt":"","text":"这道题其实就是图的遍历，将值为“1”的元素组成一个无向图，遍历这个无向图 方法1、DFS 设目前指针指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。 从 (i, j) 向此点的上下左右 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 做深度搜索。 终止条件： (i, j) 越过矩阵边界; ​ grid[i][j] == 0，代表此分支已越过岛屿边界。 搜索岛屿的同时，执行 grid[i][j] = '0'，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*1、c++11支持成员变量类内初始化，但是成员变量是数组时，必须指定大小！2、这道题用到DFS算法，是我没有想到的。原本以为DFS只是用来遍历图，树。 其实DFS是一种广泛应用的搜索算法！需要好好感受！ （二刷发现这道题就是图的遍历，哈哈哈！）*/class Solution &#123;public: //类内初始化数组必须指明数组大小 //int dx[] = &#123;-1, 1, 0, 0&#125;; 错误 int dx[4] = &#123;-1, 1, 0, 0&#125;; int dy[4] = &#123;0, 0, -1, 1&#125;; /*遍历整个矩阵，当遇到 grid[i][j] == &#x27;1&#x27; 时， 从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。 */ int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int islands = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; sink(grid, i, j); islands ++; &#125; &#125; &#125; return islands; &#125; //深度优先搜索 void sink(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123; if (i &gt;= 0 &amp;&amp; i &lt; grid.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].size() &amp;&amp; grid[i][j] == &#x27;1&#x27;) &#123; /*这一步相当关键 先把当前值设为1，可以保证没有往返下探！ */ grid[i][j] = &#x27;0&#x27;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + dx[k]; int y = j + dy[k]; sink(grid, x, y); &#125; &#125; &#125;&#125;; 1234567891011121314151617181920212223242526class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int cnt = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; sink(grid, i, j); cnt++; &#125; &#125; &#125; return cnt; &#125; void sink(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int i, int j) &#123; if (i &lt; 0 || i &gt;= grid.size() || j &lt; 0 || j &gt;= grid[0].size() || grid[i][j] == &#x27;0&#x27;)&#123; return; &#125; grid[i][j] = &#x27;0&#x27;; sink(grid, i - 1, j); sink(grid, i + 1, j); sink(grid, i, j - 1); sink(grid, i ,j + 1); &#125;&#125;; 方法2、BFS 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int cnt = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if (grid[i][j] == &#x27;1&#x27;) &#123; sink(grid, i, j); cnt++; &#125; &#125; &#125; return cnt; &#125; void sink(vector&lt;vector&lt;char&gt;&gt; &amp;grid, int i, int j) &#123; queue&lt;pair&lt;int, int&gt;&gt; que; grid[i][j] = &#x27;0&#x27;; que.push(make_pair(i, j)); while (!que.empty()) &#123; auto tmp = que.front(); que.pop(); int i1 = tmp.first; int j1 = tmp.second; if (i1 - 1 &gt;= 0 &amp;&amp; grid[i1 - 1][j1] == &#x27;1&#x27;) &#123; grid[i1 - 1][j1] = &#x27;0&#x27;; que.push(make_pair(i1 - 1, j1)); &#125; if (i1 + 1 &lt; grid.size() &amp;&amp; grid[i1 + 1][j1] == &#x27;1&#x27;) &#123; grid[i1 + 1][j1] = &#x27;0&#x27;; que.push(make_pair(i1 + 1, j1)); &#125; if (j1 - 1 &gt;= 0 &amp;&amp; grid[i1][j1 - 1] == &#x27;1&#x27;) &#123; grid[i1][j1 - 1] = &#x27;0&#x27;; que.push(make_pair(i1, j1 - 1)); &#125; if (j1 + 1 &lt; grid[0].size() &amp;&amp; grid[i1][j1 + 1] == &#x27;1&#x27;) &#123; grid[i1][j1 + 1] = &#x27;0&#x27;; que.push(make_pair(i1, j1 + 1)); &#125; &#125; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://xukang919.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://xukang919.github.io/tags/bfs/"}]},{"title":"c++ STL_集合算法","slug":"c++ STL_集合算法","date":"2020-10-22T00:43:25.000Z","updated":"2020-10-20T02:00:16.000Z","comments":true,"path":"2020/10/22/c++ STL_集合算法/","link":"","permalink":"https://xukang919.github.io/2020/10/22/c++%20STL_%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;numeric&gt;void my_print(int &amp;a)&#123; std::cout &lt;&lt; a &lt;&lt; &quot; &quot;;&#125;int main() &#123; std::vector&lt;int&gt; v1; std::vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; std::for_each(v1.begin(), v1.end(), my_print); std::cout &lt;&lt; std::endl; std::for_each(v2.begin(), v2.end(), my_print); std::cout &lt;&lt; std::endl; std::vector&lt;int&gt; v_target; v_target.resize(std::min(v1.size(), v2.size())); auto it = std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v_target.begin()); std::for_each(v_target.begin(), it, my_print); std::cout &lt;&lt; std::endl; v_target.resize(v1.size() + v2.size()); it = std::set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v_target.begin()); std::for_each(v_target.begin(), it, my_print); std::cout &lt;&lt; std::endl; v_target.resize(v1.size()); it = std::set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v_target.begin()); std::for_each(v_target.begin(), it, my_print); std::cout &lt;&lt; std::endl; v_target.resize(v2.size()); it = std::set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), v_target.begin()); std::for_each(v_target.begin(), it, my_print); std::cout &lt;&lt; std::endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xukang919.github.io/tags/STL/"},{"name":"算法","slug":"算法","permalink":"https://xukang919.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"c++ STL_查找算法","slug":"c++ STL_查找算法","date":"2020-10-21T06:45:02.000Z","updated":"2020-10-20T02:00:00.000Z","comments":true,"path":"2020/10/21/c++ STL_查找算法/","link":"","permalink":"https://xukang919.github.io/2020/10/21/c++%20STL_%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;class Person&#123;public: Person() &#123;&#125; Person(const std::string &amp;name, int age) : name(name), age(age) &#123;&#125; bool operator&gt;(const Person &amp;p) const&#123; return this-&gt;age &gt; p.age; &#125; bool operator&lt;(const Person &amp;p) const&#123; return this-&gt;age &lt; p.age; &#125; bool operator==(const Person &amp;p) const&#123; if(this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) return true; else return false; &#125; std::string name; int age;&#125;;Person &amp; my_func(Person &amp;p)&#123; p.age ++; return p;&#125;void my_print(Person &amp;p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt;p.age &lt;&lt;std::endl;&#125;class my_Print&#123;public: void operator()(Person &amp;p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt;p.age &lt;&lt;std::endl; &#125;&#125;;class my_compare&#123;public: bool operator()(const Person&amp; p)&#123; if(p.name == &quot;马超&quot;) return true; return false; &#125;&#125;;int main() &#123; Person p1(&quot;张飞&quot; , 100); Person p2(&quot;赵云&quot; , 90); Person p3(&quot;关羽&quot; , 110); Person p4(&quot;马超&quot; , 80); Person p5(&quot;黄忠&quot; , 120);// std::cout &lt;&lt; (p1&gt;p2) &lt;&lt; std::endl; std::vector&lt;Person&gt; vct; vct.push_back(p1); vct.push_back(p2); vct.push_back(p3); vct.push_back(p4); vct.push_back(p5); auto it = std::find(vct.begin(), vct.end(), Person(&quot;马超&quot; , 80)); if(it == vct.end())&#123; std::cout &lt;&lt; &quot; 没找到 &quot; &lt;&lt;std::endl; &#125; else&#123; std::cout &lt;&lt; &quot; 找到啦 &quot; &lt;&lt; std::endl; &#125; it = std::find_if(vct.begin(), vct.end(), my_compare()); if(it == vct.end())&#123; std::cout &lt;&lt; &quot; 没找到 &quot; &lt;&lt;std::endl; &#125; else&#123; std::cout &lt;&lt; &quot; 找到啦 &quot; &lt;&lt; std::endl; &#125; vct.push_back(p5); it = std::adjacent_find(vct.begin(),vct.end()); if(it == vct.end())&#123; std::cout &lt;&lt; &quot; 没找到 &quot; &lt;&lt;std::endl; &#125; else&#123; std::cout &lt;&lt; &quot; 找到啦 &quot; &lt;&lt; (*it).name &lt;&lt; std::endl; &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xukang919.github.io/tags/STL/"},{"name":"算法","slug":"算法","permalink":"https://xukang919.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"c++ STL_遍历算法","slug":"c++ STL_遍历算法","date":"2020-10-20T02:24:12.000Z","updated":"2020-10-20T01:57:22.000Z","comments":true,"path":"2020/10/20/c++ STL_遍历算法/","link":"","permalink":"https://xukang919.github.io/2020/10/20/c++%20STL_%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;class Person&#123;public: Person() &#123;&#125; Person(const std::string &amp;name, int age) : name(name), age(age) &#123;&#125; bool operator&gt;(const Person &amp;p) const&#123; return this-&gt;age &gt; p.age; &#125; bool operator&lt;(const Person &amp;p) const&#123; return this-&gt;age &lt; p.age; &#125; std::string name; int age;&#125;;Person &amp; my_func(Person &amp;p)&#123; p.age ++; return p;&#125;void my_print(Person &amp;p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt;p.age &lt;&lt;std::endl;&#125;class my_Print&#123;public: void operator()(Person &amp;p)&#123; std::cout &lt;&lt; p.name &lt;&lt; &quot; &quot; &lt;&lt;p.age &lt;&lt;std::endl; &#125;&#125;;int main() &#123; Person p1(&quot;张飞&quot; , 100); Person p2(&quot;赵云&quot; , 90); Person p3(&quot;关羽&quot; , 110); Person p4(&quot;马超&quot; , 80); Person p5(&quot;黄总&quot; , 120);// std::cout &lt;&lt; (p1&gt;p2) &lt;&lt; std::endl; std::vector&lt;Person&gt; vct; vct.push_back(p1); vct.push_back(p2); vct.push_back(p3); vct.push_back(p4); vct.push_back(p5); std::for_each(vct.begin(), vct.end(), my_func); std::for_each(vct.begin(), vct.end(), my_Print()); std::vector&lt;Person&gt; vct2; vct2.resize(vct.size()); std::transform(vct.begin(), vct.end(), vct2.begin(), my_func); std::for_each(vct2.begin(), vct2.end(), my_Print()); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;iostream&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;class Person&#123;public: Person() &#123;&#125; Person(int age, const std::string &amp;name) : age(age), name(name) &#123;&#125; Person(const Person &amp;p) &#123; this-&gt;age = p.age; this-&gt;name = p.name; &#125; //这里为什么需要加一个const bool operator&lt;(const Person &amp;p) const&#123; return this-&gt;age &lt; p.age; &#125; bool operator&gt;(const Person &amp;p) const&#123; return this-&gt;age &gt; p.age; &#125; int age; std::string name;&#125;;class MyCompare&#123;public: //这里为什么需要加const bool operator()(const Person &amp;p1, const Person &amp;p2) &#123; return p1 &gt; p2; &#125;&#125;;class AgePlus&#123;public: void operator()(Person &amp;p) &#123; p.age += 100; &#125;&#125;;template &lt;typename T&gt;void agePlus(T &amp;p) &#123; p.age += 100;&#125;void ageplus(Person &amp;p) &#123; p.age += 100;&#125;template &lt;typename T&gt;void my_print(const T &amp;t) &#123; for (auto i : t) &#123; std::cout &lt;&lt; i.name &lt;&lt; &quot; &quot; &lt;&lt; i.age &lt;&lt; std::endl; &#125;&#125;int main(int argc, char const *argv[]) &#123; Person p1(120, &quot;刘备&quot;); Person p2(119, &quot;韩信&quot;); Person p3(118, &quot;关羽&quot;); Person p4(112, &quot;张飞&quot;); Person p5(109, &quot;马超&quot;); std::cout &lt;&lt; &quot;------------------set------------------&quot; &lt;&lt; std::endl; std::set&lt;Person&gt; my_set; my_set.insert(p1); my_set.insert(p2); my_set.insert(p3); my_set.insert(p4); my_set.insert(p5); my_print(my_set); std::cout &lt;&lt; &quot;---------------&quot; &lt;&lt; std::endl; std::set&lt;Person, MyCompare&gt; my_set2; my_set2.insert(p1); my_set2.insert(p2); my_set2.insert(p3); my_set2.insert(p4); my_set2.insert(p5); my_print(my_set2); //set内的元素不能改变，迭代器被const修饰 //std::for_each(my_set.begin(), my_set.end(), ageplus);// for (auto &amp;i : my_set) &#123;// i.age ++;// &#125; std::cout &lt;&lt; &quot;------------------vector------------------&quot; &lt;&lt; std::endl; std::vector&lt;Person&gt; vct1; vct1.push_back(p1); vct1.push_back(p2); vct1.push_back(p3); vct1.push_back(p4); vct1.push_back(p5); my_print(vct1); std::cout &lt;&lt; &quot;---------------&quot; &lt;&lt; std::endl;// std::for_each(vct1.begin(), vct1.end(), ageplus);// std::for_each(vct1.begin(), vct1.end(), agePlus&lt;Person&gt;); std::for_each(vct1.begin(), vct1.end(), AgePlus()); my_print(vct1); return 0;&#125;/*------------------set------------------马超 109张飞 112关羽 118韩信 119刘备 120---------------刘备 120韩信 119关羽 118张飞 112马超 109------------------vector------------------刘备 120韩信 119关羽 118张飞 112马超 109---------------刘备 220韩信 219关羽 218张飞 212马超 209*/","categories":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://xukang919.github.io/tags/STL/"},{"name":"算法","slug":"算法","permalink":"https://xukang919.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-19T00:54:38.000Z","updated":"2020-10-19T00:54:38.000Z","comments":true,"path":"2020/10/19/hello-world/","link":"","permalink":"https://xukang919.github.io/2020/10/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Leetcode 15 三数之和","slug":"Leetcode 15 三数之和","date":"2020-09-06T07:23:45.000Z","updated":"2020-10-20T01:45:51.000Z","comments":true,"path":"2020/09/06/Leetcode 15 三数之和/","link":"","permalink":"https://xukang919.github.io/2020/09/06/Leetcode%2015%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"这道题是 两数之和 的升级，但输出有区别！ 两数之和 题目要求输出的是下标组合，但只需要输出一种情况。 三数之和 题目要求输出的所有可能的不重复的三元组。 并不是下标。 怎么样把重复的三元组过滤掉是这道题的难点！ 方法1、暴力搜索 遍历每一个元素 x, 是否能找到两个数y, z 使得 y + z = -x 时间复杂度 O(N^3) 暴力算法看似简单，但是要处理好重复元素问题，好像并没有那么容易 看了一个精选题解，一个基本暴力三重循环都没写对，一群人说好！但是也有人发现了bug，估计是喷的人也多，所以成热门了！ 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; map&lt;vector&lt;int&gt;, int&gt; my_map; int size = nums.size(); for (int i = 0; i &lt; size - 2; i++) &#123; for (int j = i + 1; j &lt; size - 1; j++) &#123; for (int k = j + 1; k &lt; size; k++) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; auto tmp = vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;; if (my_map.count(tmp) == 0) &#123; res.push_back(tmp); my_map[tmp] = 0; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 方法2、双指针 这里使用双指针，需要进行排序，跟 两数之和 一样，但是这里不需要找下标，就少了一些操作！ 我二刷了这道题，但是在二刷的时候，还是有两个地方没处理好，见下面程序注意部分！ 这道题如果不排序们无法使用双指针！ 使用双指针进行步步逼近，需要有逼近的条件！但是双指针不一样就需要排序，例如第11题 盛水最多的容器！ 解题思路： 先将给定 nums 排序，复杂度为 O(NlogN)。 指针 i遍历整个数组，双指针 j = i + 1，k =nums.size() - 1 ，双指针往中间夹逼 当 nums[i] &gt; 0 时直接break跳出。因为 nums[k] &gt;= nums[j] &gt;= nums[i] &gt; 0，即 3个数字都大于 0，不可能再找到结果了。 当 i &gt; 0且nums[i] == nums[i - 1]时即跳过此元素, 搜索结果跟上一次搜索一样! 当j &lt; k 时循环计算s = nums[i] + nums[j] + nums[k]. 并按照以下规则执行双指针移动： 当s &lt; 0时，j ++ , 但如果下个与之前的一样，仍要j ++ ，跳过所有重复的nums[j]； 当s &gt; 0时，k-- , 但如果下个与之前的一样，仍要k-- 跳过所有重复的nums[k]； 当s == 0时，记录组合[ nums[i], nums[j], nums[k]]至res 执行 j++和 k–并跳过所有重复的nums[j]和nums[k]，防止记录到重复组合。 复杂度分析： 时间复杂度 O( N^2 ) ：其中固定指针i循环复杂度 O( N )，双指针 j，k 复杂度 O( N )。 空间复杂度 O ( 1 )：指针使用常数大小的额外空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (nums.size() == 0) return res; sort(nums.begin(), nums.end()); /*注意！ 由于nums.size()得到的是无符号整数，需要转化为int 如果不转化，下面循环使用 for (int i = 0; i &lt; nums.size() - 2; i++) 测试案例为[0],就不能通过！ */ int size = nums.size(); for (int i = 0; i &lt; size - 2; i++) &#123; // 由于先排序，如果nums[k] &gt; 0,那么后面都 &gt; 0 直接退出 if (nums[i] &gt; 0) break; //如果当前nums[i] == nums[i - 1],那么搜索结果跟上一次搜索一样， //不需要再搜索,题目要求不重复的三元组 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int j = i + 1; int k = size - 1; while (j &lt; k) &#123; if (nums[j] + nums[k] + nums[i] &lt; 0) &#123; j++; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; //题目要求不重复的三元组 &#125; else if (nums[j] + nums[k] + nums[i] &gt; 0 ) &#123; k--; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; //题目要求不重复的三元组 &#125; else if (nums[j] + nums[k] + nums[i] == 0) &#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; //题目要求不重复的三元组 while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; //题目要求不重复的三元组 &#125; &#125; &#125; return res; &#125;&#125;;/* 注意！ 在while循环内！必须使用 if () &#123; &#125; else if () &#123; &#125; else &#123; &#125; 如果使用 if () &#123; &#125; if () &#123; &#125; if () &#123; &#125; 逻辑上是不同的，上面if-else嵌套，只有一个语句执行，而下面可能会多个执行！ 测试算例 为 [-1,0,1,2,-1,-4] 时 输出结果 为 [[-4,2,2],[-1,-1,2],[-1,0,1]]。 但是正确结果 为 [[-1,-1,2],[-1,0,1]]！ */ 简化升级，更加优雅的代码！ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; int my_size = nums.size(); //nums.size() 为无符号整数，转化为int int i, j; for (int k = 0; k &lt; my_size; k++) &#123; // 由于先排序，如果nums[k] &gt; 0,那么后面都 &gt; 0 直接退出 if (nums[k] &gt; 0) break; //如果当前nums[k] == nums[k - 1],那么搜索结果跟上一次搜索一样， //不需要再搜索,题目要求不重复的三元组 if (k &gt; 0 &amp;&amp; nums[k] == nums[k-1]) continue; i = k + 1, j = my_size - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] + nums[k] &lt; 0) &#123; while (i &lt; j &amp;&amp; nums[i] == nums[++i]); //题目要求不重复的三元组 &#125; else if (nums[i] + nums[j] + nums[k] &gt; 0) &#123; while (i &lt; j &amp;&amp; nums[j] == nums[--j]); //题目要求不重复的三元组 &#125; else &#123; res.push_back(&#123;nums[k], nums[i], nums[j]&#125;); while (i &lt; j &amp;&amp; nums[i] == nums[++i]); //题目要求不重复的三元组 while (i &lt; j &amp;&amp; nums[j] == nums[--j]); //题目要求不重复的三元组 &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"}]},{"title":"Leetcode 1 两数之和","slug":"Leetcode 1 两数之和","date":"2020-09-04T12:46:25.000Z","updated":"2020-10-19T15:10:22.000Z","comments":true,"path":"2020/09/04/Leetcode 1 两数之和/","link":"","permalink":"https://xukang919.github.io/2020/09/04/Leetcode%201%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"对于这道题，首先题目给出一个注意点：一个数只能用一次！但是并不代表数组没有重复元素！ 所以这算是这道题需要考虑的另一个注意点：重复元素怎么办？ map存储只能存储一个是否对这道题有用呢？ 这道题虽然看似简单，但是有一些细节的地方需要考虑清楚，在leetcode评论区，我发现好多人都没有真正理解两遍hash和一遍hash这两种方法，还有人甚至理解不能重复使用元素就是没有重复元素！ 方法1、暴力法 最简单也很容易想到，但是时间复杂度很高！ O(N^2) 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.length; i++) &#123; //j = i + 1 不能重复使用 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; res.push_back(i); res.push_back(j); return res; &#125; &#125; &#125; return res; &#125;&#125;; 方法2、双指针 刚看到这道题，我的第一想法是双指针！先排序然后双指针，用map存储下标！ 但是发现问题并没有我想得那么容易，重复问题需要仔细考虑！这里如果用map存储下标，我解决不了重复问题，从而弃用map！直接拷贝一份，在副本中查找，因为重复元素在排序后的先后顺序是不变的！ 时间复杂度 O(NlogN) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //拷贝一份 vector&lt;int&gt; tmp(nums); //排序O(NlongN) sort(nums.begin(), nums.end()); //双指针 int i = 0; int j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &lt; target) i++; if (nums[i] + nums[j] &gt; target) j--; if (nums[i] + nums[j] == target) break; &#125; vector&lt;int&gt; res; if (i == j) return res; for (int k = 0; k &lt; nums.size(); k++) &#123; if (tmp[k] == nums[i]) &#123; res.push_back(k); break; &#125; &#125; for (int k = 0; k &lt; nums.size(); k++) &#123; // k != res[0], 下标不能一样，每个元素只能使用一次 if (tmp[k] == nums[j] &amp;&amp; k != res[0]) &#123; res.push_back(k); break; &#125; &#125; return res; &#125;&#125;; 方法3、两遍hash表 在第一次迭代中，我们将每个元素的值和它的索引添加到hash表中。 在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！ 是否解决重复元素的问题！ 因为每次网hash表中添加元素的时候，重复元素会覆盖之前的下标。仔细体会！！！ 复杂度分析： 时间复杂度：O(N)， 我们把包含有 N 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) 所以时间复杂度为 O(N)。 空间复杂度：O(N)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 N 个元素。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; my_map; for (int i = 0; i &lt; nums.size(); i++) my_map.insert(pair&lt;int, int&gt;(nums[i], i)); for (int i = 0; i &lt; nums.size(); i++) &#123; // my_map[target - nums[i]] != i 不能重复使用 if (my_map.count(target - nums[i]) &amp;&amp; my_map[target - nums[i]] != i) &#123; return vector&lt;int&gt;&#123;i, my_map[target - nums[i]]&#125;; &#125; &#125; return vector&lt;int&gt;(); &#125;&#125;; 方法4、一遍hash表 怎么理解一边hash？ 可以将两遍hash合成一边hash，因为很容易发现两遍hash，在第二遍hash查找的过程中每次查找都是在整个数组范围内查找，虽然查找的时间复杂度为O(1) ，但是还可简化！！！ 其实就是对暴力搜索的直接优化! 理解暴力搜索即可！ 注意如何解决重复使用问题 其实跟暴力搜索一样，每次搜索的返回不包括本身！ 是否解决重复元素的问题！ 同样能解决重复问题 复杂度分析： 时间复杂度：O(N)， 我们只遍历了包含有 N个元素的列表一次。在表中进行的每次查找只花费O(1) 的时间。 空间复杂度：O(N)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 N 个元素。 12345678910111213141516171819202122232425/*//暴力搜索的另一种写法！vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] + nums[j] == target) return vector&lt;int&gt;&#123;i, j&#125;; &#125; &#125; return vector&lt;int&gt;&#123;&#125;; &#125; */vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; my_map; for (int i = 0; i &lt; nums.size(); i++) &#123; int complement = target - nums[i]; if (my_map.count(complement)) &#123; return vector&lt;int&gt;&#123;i, my_map[complement]&#125;; &#125; else &#123; my_map[nums[i]] = i; &#125; &#125; return vector&lt;int&gt;(); &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-11T06:22:54.000Z","updated":"2021-12-04T07:32:14.000Z","comments":true,"path":"2019/08/11/正则表达式/","link":"","permalink":"https://xukang919.github.io/2019/08/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式 1、常用匹配规则 2、常用匹配方法 match() 匹配目标 通用匹配 贪婪与非贪婪 修饰符 转义匹配 search() findall() 前面我们介绍了 search()方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要 获取匹配正则表达式的所有内容，那该怎么办呢?这时就要借助 findall()方法了。 该方法会搜索整 个字符串，然后返回匹配正则表达式的所有内容 。 如果只是获取第 一 个内容，可以用 search()方法。 当需要提取多个内容时，可以用于 findall() 方法。 sub() 除了使用正则表达式提取信息外，有时候还需要借助它来修改文本 。 比如，想要把一 串文本中的 所有数字都去掉，如果只用字符串的 replace()方法，那就太烦琐了，这时可以借助 sub()方法。 compile() 前面所讲的方法都是用来处理字符串的方法，最后再介绍一下 compile()方法，这个方法可以将 正则字符串编译成正 则表达式对象，以便在后面的匹配中复用 。 例如，这里有 3个日期，我们想分别将 3个日期中的时间去掉，这时可以借助 sub()方法。 该方 法的第一个参数是正则表达式，但是这里没有必要重复写 3 个同样的正则表达式，此时可以借助 compile()方法将正则表达式编译成一个正则表达式对象，以便复用 。","categories":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/tags/c/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/categories/c/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"},{"name":"dfs","slug":"dfs","permalink":"https://xukang919.github.io/tags/dfs/"},{"name":"bfs","slug":"bfs","permalink":"https://xukang919.github.io/tags/bfs/"},{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://xukang919.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"STL","slug":"STL","permalink":"https://xukang919.github.io/tags/STL/"},{"name":"算法","slug":"算法","permalink":"https://xukang919.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"单调栈","slug":"单调栈","permalink":"https://xukang919.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"c++","slug":"c","permalink":"https://xukang919.github.io/tags/c/"}]}