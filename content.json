{"meta":{"title":"Hello xukang","subtitle":"","description":"","author":"xukang","url":"https://xukang919.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"/404.html","permalink":"https://xukang919.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-19T04:23:41.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"about/index.html","permalink":"https://xukang919.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-10-19T03:34:26.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"books/index.html","permalink":"https://xukang919.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://xukang919.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-19T02:29:56.000Z","updated":"2020-10-19T01:27:00.000Z","comments":true,"path":"links/index.html","permalink":"https://xukang919.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-19T02:26:54.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"repository/index.html","permalink":"https://xukang919.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"tags/index.html","permalink":"https://xukang919.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-10-19T00:54:38.000Z","updated":"2020-10-19T00:54:38.000Z","comments":true,"path":"2020/10/19/hello-world/","link":"","permalink":"https://xukang919.github.io/2020/10/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Leetcode 1 两数之和","slug":"Leetcode 1 两数之和","date":"2020-09-04T12:46:25.000Z","updated":"2020-10-19T15:10:22.000Z","comments":true,"path":"2020/09/04/Leetcode 1 两数之和/","link":"","permalink":"https://xukang919.github.io/2020/09/04/Leetcode%201%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"对于这道题，首先题目给出一个注意点：一个数只能用一次！但是并不代表数组没有重复元素！ 所以这算是这道题需要考虑的另一个注意点：重复元素怎么办？ map存储只能存储一个是否对这道题有用呢？ 这道题虽然看似简单，但是有一些细节的地方需要考虑清楚，在leetcode评论区，我发现好多人都没有真正理解两遍hash和一遍hash这两种方法，还有人甚至理解不能重复使用元素就是没有重复元素！ 方法1、暴力法 最简单也很容易想到，但是时间复杂度很高！ O(N^2) 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.length; i++) &#123; //j = i + 1 不能重复使用 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; res.push_back(i); res.push_back(j); return res; &#125; &#125; &#125; return res; &#125;&#125;; 方法2、双指针 刚看到这道题，我的第一想法是双指针！先排序然后双指针，用map存储下标！ 但是发现问题并没有我想得那么容易，重复问题需要仔细考虑！这里如果用map存储下标，我解决不了重复问题，从而弃用map！直接拷贝一份，在副本中查找，因为重复元素在排序后的先后顺序是不变的！ 时间复杂度 O(NlogN) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //拷贝一份 vector&lt;int&gt; tmp(nums); //排序O(NlongN) sort(nums.begin(), nums.end()); //双指针 int i = 0; int j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &lt; target) i++; if (nums[i] + nums[j] &gt; target) j--; if (nums[i] + nums[j] == target) break; &#125; vector&lt;int&gt; res; if (i == j) return res; for (int k = 0; k &lt; nums.size(); k++) &#123; if (tmp[k] == nums[i]) &#123; res.push_back(k); break; &#125; &#125; for (int k = 0; k &lt; nums.size(); k++) &#123; // k != res[0], 下标不能一样，每个元素只能使用一次 if (tmp[k] == nums[j] &amp;&amp; k != res[0]) &#123; res.push_back(k); break; &#125; &#125; return res; &#125;&#125;; 方法3、两遍hash表 在第一次迭代中，我们将每个元素的值和它的索引添加到hash表中。 在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！ 是否解决重复元素的问题！ 因为每次网hash表中添加元素的时候，重复元素会覆盖之前的下标。仔细体会！！！ 复杂度分析： 时间复杂度：O(N)， 我们把包含有 N 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) 所以时间复杂度为 O(N)。 空间复杂度：O(N)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 N 个元素。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; my_map; for (int i = 0; i &lt; nums.size(); i++) my_map.insert(pair&lt;int, int&gt;(nums[i], i)); for (int i = 0; i &lt; nums.size(); i++) &#123; // my_map[target - nums[i]] != i 不能重复使用 if (my_map.count(target - nums[i]) &amp;&amp; my_map[target - nums[i]] != i) &#123; return vector&lt;int&gt;&#123;i, my_map[target - nums[i]]&#125;; &#125; &#125; return vector&lt;int&gt;(); &#125;&#125;; 方法4、一遍hash表 怎么理解一边hash？ 可以将两遍hash合成一边hash，因为很容易发现两遍hash，在第二遍hash查找的过程中每次查找都是在整个数组范围内查找，虽然查找的时间复杂度为O(1) ，但是还可简化！！！ 其实就是对暴力搜索的直接优化! 理解暴力搜索即可！ 注意如何解决重复使用问题 其实跟暴力搜索一样，每次搜索的返回不包括本身！ 是否解决重复元素的问题！ 同样能解决重复问题 复杂度分析： 时间复杂度：O(N)， 我们只遍历了包含有 N个元素的列表一次。在表中进行的每次查找只花费O(1) 的时间。 空间复杂度：O(N)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 N 个元素。 12345678910111213141516171819202122232425/*//暴力搜索的另一种写法！vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] + nums[j] == target) return vector&lt;int&gt;&#123;i, j&#125;; &#125; &#125; return vector&lt;int&gt;&#123;&#125;; &#125; */vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; my_map; for (int i = 0; i &lt; nums.size(); i++) &#123; int complement = target - nums[i]; if (my_map.count(complement)) &#123; return vector&lt;int&gt;&#123;i, my_map[complement]&#125;; &#125; else &#123; my_map[nums[i]] = i; &#125; &#125; return vector&lt;int&gt;(); &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"}]},{"title":"Leetcode 15 三数之和","slug":"Leetcode 15 三数之和","date":"2020-09-04T12:46:25.000Z","updated":"2020-10-20T01:31:24.000Z","comments":true,"path":"2020/09/04/Leetcode 15 三数之和/","link":"","permalink":"https://xukang919.github.io/2020/09/04/Leetcode%2015%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"这道题是 两数之和 的升级，但输出有区别！ 两数之和 题目要求输出的是下标组合，但只需要输出一种情况。 三数之和 题目要求输出的所有可能的不重复的三元组。 并不是下标。 怎么样把重复的三元组过滤掉是这道题的难点！ 方法1、暴力搜索 遍历每一个元素 x, 是否能找到两个数y, z 使得 y + z = -x 时间复杂度 O(N^3) 暴力算法看似简单，但是要处理好重复元祖问题，好像并没有那么容易 看了一个精选题解，真是笑死我了，一个基本暴力三重循环都没写对，一群人说好！但是也有人发现了bug，估计是喷的人也多，所以成热门了！ 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; map&lt;vector&lt;int&gt;, int&gt; my_map; int size = nums.size(); for (int i = 0; i &lt; size - 2; i++) &#123; for (int j = i + 1; j &lt; size - 1; j++) &#123; for (int k = j + 1; k &lt; size; k++) &#123; if (nums[i] + nums[j] + nums[k] == 0) &#123; auto tmp = vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;; if (my_map.count(tmp) == 0) &#123; res.push_back(tmp); my_map[tmp] = 0; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 方法2、双指针 这里使用双指针，需要进行排序，跟 两数之和 一样，但是这里不需要找下标，就少了一些操作！ 我二刷了这道题，但是在二刷的时候，还是有两个地方没处理好，见下面程序注意部分！ 这道题如果不排序们无法使用双指针！ 使用双指针进行步步逼近，需要有逼近的条件！但是双指针不一样就需要排序，例如第11题 盛水最多的容器！ 解题思路： 先将给定 nums 排序，复杂度为 O(NlogN)。 指针 i遍历整个数组，双指针 j = i + 1，k =nums.size() - 1 ，双指针往中间夹逼 当 nums[i] &gt; 0 时直接break跳出。因为 nums[k] &gt;= nums[j] &gt;= nums[i] &gt; 0，即 3 个数字都大于 0 ，不可能再找到结果了。 当 i &gt; 0且nums[i] == nums[i - 1]时即跳过此元素, 搜索结果跟上一次搜索一样! 当j &lt; k 时循环计算s = nums[i] + nums[j] + nums[k]. 并按照以下规则执行双指针移动： 当s &lt; 0时，j ++ , 但如果下个与之前的一样，仍要j ++ ，跳过所有重复的nums[j]； 当s &gt; 0时，k-- , 但如果下个与之前的一样，仍要k-- 跳过所有重复的nums[k]； 当s == 0时，记录组合[ nums[i], nums[j], nums[k]]至res 执行 j++和 k–并跳过所有重复的nums[j]和nums[k]，防止记录到重复组合。 复杂度分析： 时间复杂度 O( N^2 )：其中固定指针i循环复杂度 O( N ) ，双指针 j，k 复杂度 O( N ) 。 空间复杂度 O( 1 )：指针使用常数大小的额外空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (nums.size() == 0) return res; sort(nums.begin(), nums.end()); /*注意！ 由于nums.size()得到的是无符号整数，需要转化为int 如果不转化，下面循环使用 for (int i = 0; i &lt; nums.size() - 2; i++) 测试案例为[0],就不能通过！ */ int size = nums.size(); for (int i = 0; i &lt; size - 2; i++) &#123; // 由于先排序，如果nums[k] &gt; 0,那么后面都 &gt; 0 直接退出 if (nums[i] &gt; 0) break; //如果当前nums[i] == nums[i - 1],那么搜索结果跟上一次搜索一样， //不需要再搜索,题目要求不重复的三元组 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int j = i + 1; int k = size - 1; while (j &lt; k) &#123; if (nums[j] + nums[k] + nums[i] &lt; 0) &#123; j++; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; //题目要求不重复的三元组 &#125; else if (nums[j] + nums[k] + nums[i] &gt; 0 ) &#123; k--; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; //题目要求不重复的三元组 &#125; else if (nums[j] + nums[k] + nums[i] == 0) &#123; res.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++; //题目要求不重复的三元组 while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--; //题目要求不重复的三元组 &#125; &#125; &#125; return res; &#125;&#125;;/* 注意！ 在while循环内！必须使用 if () &#123; &#125; else if () &#123; &#125; else &#123; &#125; 如果使用 if () &#123; &#125; if () &#123; &#125; if () &#123; &#125; 逻辑上是不同的，上面if-else嵌套，只有一个语句执行，而下面可能会多个执行！ 测试算例 为 [-1,0,1,2,-1,-4] 时 输出结果 为 [[-4,2,2],[-1,-1,2],[-1,0,1]]。 但是正确结果 为 [[-1,-1,2],[-1,0,1]]！ */ 简化升级，更加优雅的代码！ 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; res; int my_size = nums.size(); //nums.size() 为无符号整数，转化为int int i, j; for (int k = 0; k &lt; my_size; k++) &#123; // 由于先排序，如果nums[k] &gt; 0,那么后面都 &gt; 0 直接退出 if (nums[k] &gt; 0) break; //如果当前nums[k] == nums[k - 1],那么搜索结果跟上一次搜索一样， //不需要再搜索,题目要求不重复的三元组 if (k &gt; 0 &amp;&amp; nums[k] == nums[k-1]) continue; i = k + 1, j = my_size - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] + nums[k] &lt; 0) &#123; while (i &lt; j &amp;&amp; nums[i] == nums[++i]); //题目要求不重复的三元组 &#125; else if (nums[i] + nums[j] + nums[k] &gt; 0) &#123; while (i &lt; j &amp;&amp; nums[j] == nums[--j]); //题目要求不重复的三元组 &#125; else &#123; res.push_back(&#123;nums[k], nums[i], nums[j]&#125;); while (i &lt; j &amp;&amp; nums[i] == nums[++i]); //题目要求不重复的三元组 while (i &lt; j &amp;&amp; nums[j] == nums[--j]); //题目要求不重复的三元组 &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xukang919.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://xukang919.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://xukang919.github.io/tags/Leetcode/"}]}