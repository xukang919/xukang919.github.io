{"meta":{"title":"Hello xukang","subtitle":"","description":"","author":"xukang","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-10-19T04:23:41.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-10-19T03:34:26.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-10-19T02:29:56.000Z","updated":"2020-10-19T01:27:00.000Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-10-19T02:26:54.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-19T04:25:20.000Z","updated":"2020-10-19T01:27:00.000Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-10-19T00:54:38.000Z","updated":"2020-10-19T00:54:38.000Z","comments":true,"path":"2020/10/19/hello-world/","link":"","permalink":"http://example.com/2020/10/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Leetcode 1 两数之和","slug":"Leetcode 1 两数之和","date":"2020-09-04T12:46:25.000Z","updated":"2020-10-19T15:10:22.000Z","comments":true,"path":"2020/09/04/Leetcode 1 两数之和/","link":"","permalink":"http://example.com/2020/09/04/Leetcode%201%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"对于这道题，首先题目给出一个注意点：一个数只能用一次！但是并不代表数组没有重复元素！ 所以这算是这道题需要考虑的另一个注意点：重复元素怎么办？ map存储只能存储一个是否对这道题有用呢？ 这道题虽然看似简单，但是有一些细节的地方需要考虑清楚，在leetcode评论区，我发现好多人都没有真正理解两遍hash和一遍hash这两种方法，还有人甚至理解不能重复使用元素就是没有重复元素！ 方法1、暴力法 最简单也很容易想到，但是时间复杂度很高！ O(N^2) 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.length; i++) &#123; //j = i + 1 不能重复使用 for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; res.push_back(i); res.push_back(j); return res; &#125; &#125; &#125; return res; &#125;&#125;; 方法2、双指针 刚看到这道题，我的第一想法是双指针！先排序然后双指针，用map存储下标！ 但是发现问题并没有我想得那么容易，重复问题需要仔细考虑！这里如果用map存储下标，我解决不了重复问题，从而弃用map！直接拷贝一份，在副本中查找，因为重复元素在排序后的先后顺序是不变的！ 时间复杂度 O(NlogN) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; //拷贝一份 vector&lt;int&gt; tmp(nums); //排序O(NlongN) sort(nums.begin(), nums.end()); //双指针 int i = 0; int j = nums.size() - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &lt; target) i++; if (nums[i] + nums[j] &gt; target) j--; if (nums[i] + nums[j] == target) break; &#125; vector&lt;int&gt; res; if (i == j) return res; for (int k = 0; k &lt; nums.size(); k++) &#123; if (tmp[k] == nums[i]) &#123; res.push_back(k); break; &#125; &#125; for (int k = 0; k &lt; nums.size(); k++) &#123; // k != res[0], 下标不能一样，每个元素只能使用一次 if (tmp[k] == nums[j] &amp;&amp; k != res[0]) &#123; res.push_back(k); break; &#125; &#125; return res; &#125;&#125;; 方法3、两遍hash表 在第一次迭代中，我们将每个元素的值和它的索引添加到hash表中。 在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！ 是否解决重复元素的问题！ 因为每次网hash表中添加元素的时候，重复元素会覆盖之前的下标。仔细体会！！！ 复杂度分析： 时间复杂度：O(N)， 我们把包含有 N 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) 所以时间复杂度为 O(N)。 空间复杂度：O(N)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 N 个元素。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; my_map; for (int i = 0; i &lt; nums.size(); i++) my_map.insert(pair&lt;int, int&gt;(nums[i], i)); for (int i = 0; i &lt; nums.size(); i++) &#123; // my_map[target - nums[i]] != i 不能重复使用 if (my_map.count(target - nums[i]) &amp;&amp; my_map[target - nums[i]] != i) &#123; return vector&lt;int&gt;&#123;i, my_map[target - nums[i]]&#125;; &#125; &#125; return vector&lt;int&gt;(); &#125;&#125;; 方法4、一遍hash表 怎么理解一边hash？ 可以将两遍hash合成一边hash，因为很容易发现两遍hash，在第二遍hash查找的过程中每次查找都是在整个数组范围内查找，虽然查找的时间复杂度为O(1) ，但是还可简化！！！ 其实就是对暴力搜索的直接优化! 理解暴力搜索即可！ 注意如何解决重复使用问题 其实跟暴力搜索一样，每次搜索的返回不包括本身！ 是否解决重复元素的问题！ 同样能解决重复问题 复杂度分析： 时间复杂度：O(N)， 我们只遍历了包含有 N个元素的列表一次。在表中进行的每次查找只花费O(1) 的时间。 空间复杂度：O(N)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 N 个元素。 12345678910111213141516171819202122232425/*//暴力搜索的另一种写法！vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (nums[i] + nums[j] == target) return vector&lt;int&gt;&#123;i, j&#125;; &#125; &#125; return vector&lt;int&gt;&#123;&#125;; &#125; */vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; my_map; for (int i = 0; i &lt; nums.size(); i++) &#123; int complement = target - nums[i]; if (my_map.count(complement)) &#123; return vector&lt;int&gt;&#123;i, my_map[complement]&#125;; &#125; else &#123; my_map[nums[i]] = i; &#125; &#125; return vector&lt;int&gt;(); &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"}]}